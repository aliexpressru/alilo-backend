// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// SimpleScript is an object representing the database table.
type SimpleScript struct {
	ScriptID        int32             `boil:"script_id" json:"script_id" toml:"script_id" yaml:"script_id"`
	Name            string            `boil:"name" json:"name" toml:"name" yaml:"name"`
	Description     string            `boil:"description" json:"description" toml:"description" yaml:"description"`
	ProjectID       int32             `boil:"project_id" json:"project_id" toml:"project_id" yaml:"project_id"`
	ScenarioID      int32             `boil:"scenario_id" json:"scenario_id" toml:"scenario_id" yaml:"scenario_id"`
	Enabled         bool              `boil:"enabled" json:"enabled" toml:"enabled" yaml:"enabled"`
	MonitoringLinks types.StringArray `boil:"monitoring_links" json:"monitoring_links" toml:"monitoring_links" yaml:"monitoring_links"`
	Tag             string            `boil:"tag" json:"tag" toml:"tag" yaml:"tag"`
	Scheme          string            `boil:"scheme" json:"scheme" toml:"scheme" yaml:"scheme"`
	Path            string            `boil:"path" json:"path" toml:"path" yaml:"path"`
	HTTPMethod      string            `boil:"http_method" json:"http_method" toml:"http_method" yaml:"http_method"`
	ScriptFileURL   string            `boil:"script_file_url" json:"script_file_url" toml:"script_file_url" yaml:"script_file_url"`
	StaticAmmo      string            `boil:"static_ammo" json:"static_ammo" toml:"static_ammo" yaml:"static_ammo"`
	AmmoURL         string            `boil:"ammo_url" json:"ammo_url" toml:"ammo_url" yaml:"ammo_url"`
	IsStaticAmmo    bool              `boil:"is_static_ammo" json:"is_static_ammo" toml:"is_static_ammo" yaml:"is_static_ammo"`
	RPS             string            `boil:"rps" json:"rps" toml:"rps" yaml:"rps"`
	Duration        string            `boil:"duration" json:"duration" toml:"duration" yaml:"duration"`
	Steps           string            `boil:"steps" json:"steps" toml:"steps" yaml:"steps"`
	MaxVUs          string            `boil:"max_v_us" json:"max_v_us" toml:"max_v_us" yaml:"max_v_us"`
	QueryParams     string            `boil:"query_params" json:"query_params" toml:"query_params" yaml:"query_params"`
	Headers         string            `boil:"headers" json:"headers" toml:"headers" yaml:"headers"`
	CreatedAt       time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt       null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt       null.Time         `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	ExprRPS         string            `boil:"expr_rps" json:"expr_rps" toml:"expr_rps" yaml:"expr_rps"`
	SourceRPS       string            `boil:"source_rps" json:"source_rps" toml:"source_rps" yaml:"source_rps"`
	CMTRPS          string            `boil:"cmt_rps" json:"cmt_rps" toml:"cmt_rps" yaml:"cmt_rps"`
	ExprRT          string            `boil:"expr_rt" json:"expr_rt" toml:"expr_rt" yaml:"expr_rt"`
	SourceRT        string            `boil:"source_rt" json:"source_rt" toml:"source_rt" yaml:"source_rt"`
	CMTRT           string            `boil:"cmt_rt" json:"cmt_rt" toml:"cmt_rt" yaml:"cmt_rt"`
	ExprErr         string            `boil:"expr_err" json:"expr_err" toml:"expr_err" yaml:"expr_err"`
	SourceErr       string            `boil:"source_err" json:"source_err" toml:"source_err" yaml:"source_err"`
	CMTErr          string            `boil:"cmt_err" json:"cmt_err" toml:"cmt_err" yaml:"cmt_err"`
	AdditionalEnv   string            `boil:"additional_env" json:"additional_env" toml:"additional_env" yaml:"additional_env"`
	Title           string            `boil:"title" json:"title" toml:"title" yaml:"title"`

	R *simpleScriptR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L simpleScriptL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SimpleScriptColumns = struct {
	ScriptID        string
	Name            string
	Description     string
	ProjectID       string
	ScenarioID      string
	Enabled         string
	MonitoringLinks string
	Tag             string
	Scheme          string
	Path            string
	HTTPMethod      string
	ScriptFileURL   string
	StaticAmmo      string
	AmmoURL         string
	IsStaticAmmo    string
	RPS             string
	Duration        string
	Steps           string
	MaxVUs          string
	QueryParams     string
	Headers         string
	CreatedAt       string
	UpdatedAt       string
	DeletedAt       string
	ExprRPS         string
	SourceRPS       string
	CMTRPS          string
	ExprRT          string
	SourceRT        string
	CMTRT           string
	ExprErr         string
	SourceErr       string
	CMTErr          string
	AdditionalEnv   string
	Title           string
}{
	ScriptID:        "script_id",
	Name:            "name",
	Description:     "description",
	ProjectID:       "project_id",
	ScenarioID:      "scenario_id",
	Enabled:         "enabled",
	MonitoringLinks: "monitoring_links",
	Tag:             "tag",
	Scheme:          "scheme",
	Path:            "path",
	HTTPMethod:      "http_method",
	ScriptFileURL:   "script_file_url",
	StaticAmmo:      "static_ammo",
	AmmoURL:         "ammo_url",
	IsStaticAmmo:    "is_static_ammo",
	RPS:             "rps",
	Duration:        "duration",
	Steps:           "steps",
	MaxVUs:          "max_v_us",
	QueryParams:     "query_params",
	Headers:         "headers",
	CreatedAt:       "created_at",
	UpdatedAt:       "updated_at",
	DeletedAt:       "deleted_at",
	ExprRPS:         "expr_rps",
	SourceRPS:       "source_rps",
	CMTRPS:          "cmt_rps",
	ExprRT:          "expr_rt",
	SourceRT:        "source_rt",
	CMTRT:           "cmt_rt",
	ExprErr:         "expr_err",
	SourceErr:       "source_err",
	CMTErr:          "cmt_err",
	AdditionalEnv:   "additional_env",
	Title:           "title",
}

var SimpleScriptTableColumns = struct {
	ScriptID        string
	Name            string
	Description     string
	ProjectID       string
	ScenarioID      string
	Enabled         string
	MonitoringLinks string
	Tag             string
	Scheme          string
	Path            string
	HTTPMethod      string
	ScriptFileURL   string
	StaticAmmo      string
	AmmoURL         string
	IsStaticAmmo    string
	RPS             string
	Duration        string
	Steps           string
	MaxVUs          string
	QueryParams     string
	Headers         string
	CreatedAt       string
	UpdatedAt       string
	DeletedAt       string
	ExprRPS         string
	SourceRPS       string
	CMTRPS          string
	ExprRT          string
	SourceRT        string
	CMTRT           string
	ExprErr         string
	SourceErr       string
	CMTErr          string
	AdditionalEnv   string
	Title           string
}{
	ScriptID:        "simple_scripts.script_id",
	Name:            "simple_scripts.name",
	Description:     "simple_scripts.description",
	ProjectID:       "simple_scripts.project_id",
	ScenarioID:      "simple_scripts.scenario_id",
	Enabled:         "simple_scripts.enabled",
	MonitoringLinks: "simple_scripts.monitoring_links",
	Tag:             "simple_scripts.tag",
	Scheme:          "simple_scripts.scheme",
	Path:            "simple_scripts.path",
	HTTPMethod:      "simple_scripts.http_method",
	ScriptFileURL:   "simple_scripts.script_file_url",
	StaticAmmo:      "simple_scripts.static_ammo",
	AmmoURL:         "simple_scripts.ammo_url",
	IsStaticAmmo:    "simple_scripts.is_static_ammo",
	RPS:             "simple_scripts.rps",
	Duration:        "simple_scripts.duration",
	Steps:           "simple_scripts.steps",
	MaxVUs:          "simple_scripts.max_v_us",
	QueryParams:     "simple_scripts.query_params",
	Headers:         "simple_scripts.headers",
	CreatedAt:       "simple_scripts.created_at",
	UpdatedAt:       "simple_scripts.updated_at",
	DeletedAt:       "simple_scripts.deleted_at",
	ExprRPS:         "simple_scripts.expr_rps",
	SourceRPS:       "simple_scripts.source_rps",
	CMTRPS:          "simple_scripts.cmt_rps",
	ExprRT:          "simple_scripts.expr_rt",
	SourceRT:        "simple_scripts.source_rt",
	CMTRT:           "simple_scripts.cmt_rt",
	ExprErr:         "simple_scripts.expr_err",
	SourceErr:       "simple_scripts.source_err",
	CMTErr:          "simple_scripts.cmt_err",
	AdditionalEnv:   "simple_scripts.additional_env",
	Title:           "simple_scripts.title",
}

// Generated where

var SimpleScriptWhere = struct {
	ScriptID        whereHelperint32
	Name            whereHelperstring
	Description     whereHelperstring
	ProjectID       whereHelperint32
	ScenarioID      whereHelperint32
	Enabled         whereHelperbool
	MonitoringLinks whereHelpertypes_StringArray
	Tag             whereHelperstring
	Scheme          whereHelperstring
	Path            whereHelperstring
	HTTPMethod      whereHelperstring
	ScriptFileURL   whereHelperstring
	StaticAmmo      whereHelperstring
	AmmoURL         whereHelperstring
	IsStaticAmmo    whereHelperbool
	RPS             whereHelperstring
	Duration        whereHelperstring
	Steps           whereHelperstring
	MaxVUs          whereHelperstring
	QueryParams     whereHelperstring
	Headers         whereHelperstring
	CreatedAt       whereHelpertime_Time
	UpdatedAt       whereHelpernull_Time
	DeletedAt       whereHelpernull_Time
	ExprRPS         whereHelperstring
	SourceRPS       whereHelperstring
	CMTRPS          whereHelperstring
	ExprRT          whereHelperstring
	SourceRT        whereHelperstring
	CMTRT           whereHelperstring
	ExprErr         whereHelperstring
	SourceErr       whereHelperstring
	CMTErr          whereHelperstring
	AdditionalEnv   whereHelperstring
	Title           whereHelperstring
}{
	ScriptID:        whereHelperint32{field: "\"simple_scripts\".\"script_id\""},
	Name:            whereHelperstring{field: "\"simple_scripts\".\"name\""},
	Description:     whereHelperstring{field: "\"simple_scripts\".\"description\""},
	ProjectID:       whereHelperint32{field: "\"simple_scripts\".\"project_id\""},
	ScenarioID:      whereHelperint32{field: "\"simple_scripts\".\"scenario_id\""},
	Enabled:         whereHelperbool{field: "\"simple_scripts\".\"enabled\""},
	MonitoringLinks: whereHelpertypes_StringArray{field: "\"simple_scripts\".\"monitoring_links\""},
	Tag:             whereHelperstring{field: "\"simple_scripts\".\"tag\""},
	Scheme:          whereHelperstring{field: "\"simple_scripts\".\"scheme\""},
	Path:            whereHelperstring{field: "\"simple_scripts\".\"path\""},
	HTTPMethod:      whereHelperstring{field: "\"simple_scripts\".\"http_method\""},
	ScriptFileURL:   whereHelperstring{field: "\"simple_scripts\".\"script_file_url\""},
	StaticAmmo:      whereHelperstring{field: "\"simple_scripts\".\"static_ammo\""},
	AmmoURL:         whereHelperstring{field: "\"simple_scripts\".\"ammo_url\""},
	IsStaticAmmo:    whereHelperbool{field: "\"simple_scripts\".\"is_static_ammo\""},
	RPS:             whereHelperstring{field: "\"simple_scripts\".\"rps\""},
	Duration:        whereHelperstring{field: "\"simple_scripts\".\"duration\""},
	Steps:           whereHelperstring{field: "\"simple_scripts\".\"steps\""},
	MaxVUs:          whereHelperstring{field: "\"simple_scripts\".\"max_v_us\""},
	QueryParams:     whereHelperstring{field: "\"simple_scripts\".\"query_params\""},
	Headers:         whereHelperstring{field: "\"simple_scripts\".\"headers\""},
	CreatedAt:       whereHelpertime_Time{field: "\"simple_scripts\".\"created_at\""},
	UpdatedAt:       whereHelpernull_Time{field: "\"simple_scripts\".\"updated_at\""},
	DeletedAt:       whereHelpernull_Time{field: "\"simple_scripts\".\"deleted_at\""},
	ExprRPS:         whereHelperstring{field: "\"simple_scripts\".\"expr_rps\""},
	SourceRPS:       whereHelperstring{field: "\"simple_scripts\".\"source_rps\""},
	CMTRPS:          whereHelperstring{field: "\"simple_scripts\".\"cmt_rps\""},
	ExprRT:          whereHelperstring{field: "\"simple_scripts\".\"expr_rt\""},
	SourceRT:        whereHelperstring{field: "\"simple_scripts\".\"source_rt\""},
	CMTRT:           whereHelperstring{field: "\"simple_scripts\".\"cmt_rt\""},
	ExprErr:         whereHelperstring{field: "\"simple_scripts\".\"expr_err\""},
	SourceErr:       whereHelperstring{field: "\"simple_scripts\".\"source_err\""},
	CMTErr:          whereHelperstring{field: "\"simple_scripts\".\"cmt_err\""},
	AdditionalEnv:   whereHelperstring{field: "\"simple_scripts\".\"additional_env\""},
	Title:           whereHelperstring{field: "\"simple_scripts\".\"title\""},
}

// SimpleScriptRels is where relationship names are stored.
var SimpleScriptRels = struct {
	Scenario string
}{
	Scenario: "Scenario",
}

// simpleScriptR is where relationships are stored.
type simpleScriptR struct {
	Scenario *Scenario `boil:"Scenario" json:"Scenario" toml:"Scenario" yaml:"Scenario"`
}

// NewStruct creates a new relationship struct
func (*simpleScriptR) NewStruct() *simpleScriptR {
	return &simpleScriptR{}
}

func (o *SimpleScript) GetScenario() *Scenario {
	if o == nil {
		return nil
	}

	return o.R.GetScenario()
}

func (r *simpleScriptR) GetScenario() *Scenario {
	if r == nil {
		return nil
	}

	return r.Scenario
}

// simpleScriptL is where Load methods for each relationship are stored.
type simpleScriptL struct{}

var (
	simpleScriptAllColumns            = []string{"script_id", "name", "description", "project_id", "scenario_id", "enabled", "monitoring_links", "tag", "scheme", "path", "http_method", "script_file_url", "static_ammo", "ammo_url", "is_static_ammo", "rps", "duration", "steps", "max_v_us", "query_params", "headers", "created_at", "updated_at", "deleted_at", "expr_rps", "source_rps", "cmt_rps", "expr_rt", "source_rt", "cmt_rt", "expr_err", "source_err", "cmt_err", "additional_env", "title"}
	simpleScriptColumnsWithoutDefault = []string{"project_id", "scenario_id", "title"}
	simpleScriptColumnsWithDefault    = []string{"script_id", "name", "description", "enabled", "monitoring_links", "tag", "scheme", "path", "http_method", "script_file_url", "static_ammo", "ammo_url", "is_static_ammo", "rps", "duration", "steps", "max_v_us", "query_params", "headers", "created_at", "updated_at", "deleted_at", "expr_rps", "source_rps", "cmt_rps", "expr_rt", "source_rt", "cmt_rt", "expr_err", "source_err", "cmt_err", "additional_env"}
	simpleScriptPrimaryKeyColumns     = []string{"script_id"}
	simpleScriptGeneratedColumns      = []string{}
)

type (
	// SimpleScriptSlice is an alias for a slice of pointers to SimpleScript.
	// This should almost always be used instead of []SimpleScript.
	SimpleScriptSlice []*SimpleScript
	// SimpleScriptHook is the signature for custom SimpleScript hook methods
	SimpleScriptHook func(context.Context, boil.ContextExecutor, *SimpleScript) error

	simpleScriptQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	simpleScriptType                 = reflect.TypeOf(&SimpleScript{})
	simpleScriptMapping              = queries.MakeStructMapping(simpleScriptType)
	simpleScriptPrimaryKeyMapping, _ = queries.BindMapping(simpleScriptType, simpleScriptMapping, simpleScriptPrimaryKeyColumns)
	simpleScriptInsertCacheMut       sync.RWMutex
	simpleScriptInsertCache          = make(map[string]insertCache)
	simpleScriptUpdateCacheMut       sync.RWMutex
	simpleScriptUpdateCache          = make(map[string]updateCache)
	simpleScriptUpsertCacheMut       sync.RWMutex
	simpleScriptUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var simpleScriptAfterSelectMu sync.Mutex
var simpleScriptAfterSelectHooks []SimpleScriptHook

var simpleScriptBeforeInsertMu sync.Mutex
var simpleScriptBeforeInsertHooks []SimpleScriptHook
var simpleScriptAfterInsertMu sync.Mutex
var simpleScriptAfterInsertHooks []SimpleScriptHook

var simpleScriptBeforeUpdateMu sync.Mutex
var simpleScriptBeforeUpdateHooks []SimpleScriptHook
var simpleScriptAfterUpdateMu sync.Mutex
var simpleScriptAfterUpdateHooks []SimpleScriptHook

var simpleScriptBeforeDeleteMu sync.Mutex
var simpleScriptBeforeDeleteHooks []SimpleScriptHook
var simpleScriptAfterDeleteMu sync.Mutex
var simpleScriptAfterDeleteHooks []SimpleScriptHook

var simpleScriptBeforeUpsertMu sync.Mutex
var simpleScriptBeforeUpsertHooks []SimpleScriptHook
var simpleScriptAfterUpsertMu sync.Mutex
var simpleScriptAfterUpsertHooks []SimpleScriptHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SimpleScript) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SimpleScript) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SimpleScript) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SimpleScript) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SimpleScript) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SimpleScript) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SimpleScript) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SimpleScript) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SimpleScript) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range simpleScriptAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSimpleScriptHook registers your hook function for all future operations.
func AddSimpleScriptHook(hookPoint boil.HookPoint, simpleScriptHook SimpleScriptHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		simpleScriptAfterSelectMu.Lock()
		simpleScriptAfterSelectHooks = append(simpleScriptAfterSelectHooks, simpleScriptHook)
		simpleScriptAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		simpleScriptBeforeInsertMu.Lock()
		simpleScriptBeforeInsertHooks = append(simpleScriptBeforeInsertHooks, simpleScriptHook)
		simpleScriptBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		simpleScriptAfterInsertMu.Lock()
		simpleScriptAfterInsertHooks = append(simpleScriptAfterInsertHooks, simpleScriptHook)
		simpleScriptAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		simpleScriptBeforeUpdateMu.Lock()
		simpleScriptBeforeUpdateHooks = append(simpleScriptBeforeUpdateHooks, simpleScriptHook)
		simpleScriptBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		simpleScriptAfterUpdateMu.Lock()
		simpleScriptAfterUpdateHooks = append(simpleScriptAfterUpdateHooks, simpleScriptHook)
		simpleScriptAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		simpleScriptBeforeDeleteMu.Lock()
		simpleScriptBeforeDeleteHooks = append(simpleScriptBeforeDeleteHooks, simpleScriptHook)
		simpleScriptBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		simpleScriptAfterDeleteMu.Lock()
		simpleScriptAfterDeleteHooks = append(simpleScriptAfterDeleteHooks, simpleScriptHook)
		simpleScriptAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		simpleScriptBeforeUpsertMu.Lock()
		simpleScriptBeforeUpsertHooks = append(simpleScriptBeforeUpsertHooks, simpleScriptHook)
		simpleScriptBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		simpleScriptAfterUpsertMu.Lock()
		simpleScriptAfterUpsertHooks = append(simpleScriptAfterUpsertHooks, simpleScriptHook)
		simpleScriptAfterUpsertMu.Unlock()
	}
}

// One returns a single simpleScript record from the query.
func (q simpleScriptQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SimpleScript, error) {
	o := &SimpleScript{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for simple_scripts")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SimpleScript records from the query.
func (q simpleScriptQuery) All(ctx context.Context, exec boil.ContextExecutor) (SimpleScriptSlice, error) {
	var o []*SimpleScript

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SimpleScript slice")
	}

	if len(simpleScriptAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SimpleScript records in the query.
func (q simpleScriptQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count simple_scripts rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q simpleScriptQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if simple_scripts exists")
	}

	return count > 0, nil
}

// Scenario pointed to by the foreign key.
func (o *SimpleScript) Scenario(mods ...qm.QueryMod) scenarioQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"scenario_id\" = ?", o.ScenarioID),
	}

	queryMods = append(queryMods, mods...)

	return Scenarios(queryMods...)
}

// LoadScenario allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (simpleScriptL) LoadScenario(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSimpleScript interface{}, mods queries.Applicator) error {
	var slice []*SimpleScript
	var object *SimpleScript

	if singular {
		var ok bool
		object, ok = maybeSimpleScript.(*SimpleScript)
		if !ok {
			object = new(SimpleScript)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSimpleScript)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSimpleScript))
			}
		}
	} else {
		s, ok := maybeSimpleScript.(*[]*SimpleScript)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSimpleScript)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSimpleScript))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &simpleScriptR{}
		}
		args[object.ScenarioID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &simpleScriptR{}
			}

			args[obj.ScenarioID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`scenarios`),
		qm.WhereIn(`scenarios.scenario_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Scenario")
	}

	var resultSlice []*Scenario
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Scenario")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for scenarios")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for scenarios")
	}

	if len(scenarioAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Scenario = foreign
		if foreign.R == nil {
			foreign.R = &scenarioR{}
		}
		foreign.R.SimpleScripts = append(foreign.R.SimpleScripts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ScenarioID == foreign.ScenarioID {
				local.R.Scenario = foreign
				if foreign.R == nil {
					foreign.R = &scenarioR{}
				}
				foreign.R.SimpleScripts = append(foreign.R.SimpleScripts, local)
				break
			}
		}
	}

	return nil
}

// SetScenario of the simpleScript to the related item.
// Sets o.R.Scenario to related.
// Adds o to related.R.SimpleScripts.
func (o *SimpleScript) SetScenario(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Scenario) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"simple_scripts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"scenario_id"}),
		strmangle.WhereClause("\"", "\"", 2, simpleScriptPrimaryKeyColumns),
	)
	values := []interface{}{related.ScenarioID, o.ScriptID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ScenarioID = related.ScenarioID
	if o.R == nil {
		o.R = &simpleScriptR{
			Scenario: related,
		}
	} else {
		o.R.Scenario = related
	}

	if related.R == nil {
		related.R = &scenarioR{
			SimpleScripts: SimpleScriptSlice{o},
		}
	} else {
		related.R.SimpleScripts = append(related.R.SimpleScripts, o)
	}

	return nil
}

// SimpleScripts retrieves all the records using an executor.
func SimpleScripts(mods ...qm.QueryMod) simpleScriptQuery {
	mods = append(mods, qm.From("\"simple_scripts\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"simple_scripts\".*"})
	}

	return simpleScriptQuery{q}
}

// FindSimpleScript retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSimpleScript(ctx context.Context, exec boil.ContextExecutor, scriptID int32, selectCols ...string) (*SimpleScript, error) {
	simpleScriptObj := &SimpleScript{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"simple_scripts\" where \"script_id\"=$1", sel,
	)

	q := queries.Raw(query, scriptID)

	err := q.Bind(ctx, exec, simpleScriptObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from simple_scripts")
	}

	if err = simpleScriptObj.doAfterSelectHooks(ctx, exec); err != nil {
		return simpleScriptObj, err
	}

	return simpleScriptObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SimpleScript) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no simple_scripts provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(simpleScriptColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	simpleScriptInsertCacheMut.RLock()
	cache, cached := simpleScriptInsertCache[key]
	simpleScriptInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			simpleScriptAllColumns,
			simpleScriptColumnsWithDefault,
			simpleScriptColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(simpleScriptType, simpleScriptMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(simpleScriptType, simpleScriptMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"simple_scripts\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"simple_scripts\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into simple_scripts")
	}

	if !cached {
		simpleScriptInsertCacheMut.Lock()
		simpleScriptInsertCache[key] = cache
		simpleScriptInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SimpleScript.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SimpleScript) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	simpleScriptUpdateCacheMut.RLock()
	cache, cached := simpleScriptUpdateCache[key]
	simpleScriptUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			simpleScriptAllColumns,
			simpleScriptPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update simple_scripts, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"simple_scripts\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, simpleScriptPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(simpleScriptType, simpleScriptMapping, append(wl, simpleScriptPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update simple_scripts row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for simple_scripts")
	}

	if !cached {
		simpleScriptUpdateCacheMut.Lock()
		simpleScriptUpdateCache[key] = cache
		simpleScriptUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q simpleScriptQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for simple_scripts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for simple_scripts")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SimpleScriptSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), simpleScriptPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"simple_scripts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, simpleScriptPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in simpleScript slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all simpleScript")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SimpleScript) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no simple_scripts provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(simpleScriptColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	simpleScriptUpsertCacheMut.RLock()
	cache, cached := simpleScriptUpsertCache[key]
	simpleScriptUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			simpleScriptAllColumns,
			simpleScriptColumnsWithDefault,
			simpleScriptColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			simpleScriptAllColumns,
			simpleScriptPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert simple_scripts, could not build update column list")
		}

		ret := strmangle.SetComplement(simpleScriptAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(simpleScriptPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert simple_scripts, could not build conflict column list")
			}

			conflict = make([]string, len(simpleScriptPrimaryKeyColumns))
			copy(conflict, simpleScriptPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"simple_scripts\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(simpleScriptType, simpleScriptMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(simpleScriptType, simpleScriptMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert simple_scripts")
	}

	if !cached {
		simpleScriptUpsertCacheMut.Lock()
		simpleScriptUpsertCache[key] = cache
		simpleScriptUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SimpleScript record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SimpleScript) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SimpleScript provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), simpleScriptPrimaryKeyMapping)
	sql := "DELETE FROM \"simple_scripts\" WHERE \"script_id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from simple_scripts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for simple_scripts")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q simpleScriptQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no simpleScriptQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from simple_scripts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for simple_scripts")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SimpleScriptSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(simpleScriptBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), simpleScriptPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"simple_scripts\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, simpleScriptPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from simpleScript slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for simple_scripts")
	}

	if len(simpleScriptAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SimpleScript) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSimpleScript(ctx, exec, o.ScriptID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SimpleScriptSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SimpleScriptSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), simpleScriptPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"simple_scripts\".* FROM \"simple_scripts\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, simpleScriptPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SimpleScriptSlice")
	}

	*o = slice

	return nil
}

// SimpleScriptExists checks if the SimpleScript row exists.
func SimpleScriptExists(ctx context.Context, exec boil.ContextExecutor, scriptID int32) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"simple_scripts\" where \"script_id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, scriptID)
	}
	row := exec.QueryRowContext(ctx, sql, scriptID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if simple_scripts exists")
	}

	return exists, nil
}

// Exists checks if the SimpleScript row exists.
func (o *SimpleScript) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return SimpleScriptExists(ctx, exec, o.ScriptID)
}
